# User Memory

## Code Preferences
- Prefer concise, readable code
- Use meaningful variable names
- Follow existing project conventions

## Enhanced Plan Mode Analysis Framework
When in plan mode and working on coding tasks, follow this enhanced analytical framework to provide more thoughtful, comprehensive analysis rather than jumping straight to implementation details.

### 1. Question Assumptions First
- **Challenge the premise**: Is the requested approach the right solution?
- **Examine context**: What are the different ways users might encounter this problem?
- **Consider alternatives**: What other approaches could address the underlying need?
- **Validate necessity**: Is this feature actually needed, or is there a simpler solution?

### 2. Analyze Ecosystem Implications
- **Integration concerns**: How does this interact with existing tools/systems?
- **Compatibility issues**: What different environments/setups must be considered?
- **Dependency conflicts**: Could this interfere with existing dependencies, build systems, or other tooling?
- **Standards compliance**: Does this follow established patterns in the ecosystem?

### 3. Provide a Spectrum of Solutions
- **Minimal/Safe approach**: What's the lowest-risk way to address this?
- **Progressive enhancement**: How can we build up from simple to more complex?
- **Full-featured solution**: What would the complete implementation look like?
- **Alternative paradigms**: Are there completely different approaches worth considering?

### 4. Highlight Trade-offs Explicitly
- **Security vs. Convenience**: What risks come with each approach?
- **Complexity vs. Maintainability**: How will each solution age?
- **Performance vs. Features**: What are the resource implications?
- **User Experience vs. Safety**: Where do we draw boundaries?

### 5. Pattern Classification
- **Identify if this is**: A good pattern, anti-pattern, or context-dependent
- **Reference industry examples**: How do established tools handle similar problems?
- **Consider failure modes**: What could go wrong with each approach?

## Personal Shortcuts
- Add common commands or workflows here

## Development Environment
- Add your preferred tools and configurations

## Using Gemini
Use gemini when:
- Analyzing entire codebases or large directories
- Comparing multiple large files
- Need to understand project-wide patterns or architecture
- Current context window is insufficient for the task
- Working with files totaling more than 100KB
- Verifying if specific features, patterns, or security measures are implemented
- Checking for the presence of certain coding patterns across the entire codebase

Important Notes:
- Paths in @ syntax are relative to your current working directory when invoking gemini
- Gemini's context window can handle entire codebases that would overflow Claude's context
- When checking implementations, be specific about what you're looking for to get accurate results
